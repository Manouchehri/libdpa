#!/usr/bin/env python
import re

#define some shorter names
typenames = {
	'int8_t': 's8',
	'uint8_t': 'u8',
	'uint16_t': 'u16',
	'uint64_t': 'u64',
	    }

#define combinations that shall be available in the library
combinations = [
	("int8_t", "int8_t"),
	("int8_t", "uint8_t"),
	("uint8_t", "uint8_t"),
	("uint16_t", "uint8_t"),
	("uint16_t", "uint16_t"),
	("uint64_t", "uint8_t"),
	("uint64_t", "uint16_t"),
	("float", "uint8_t"),
	("float", "uint16_t"),
	("float", "uint64_t"),
	("float", "double"),
	("double", "float"),
	("double", "double"),
	("uint16_t", "float"),
	("uint8_t", "float"),
	("float", "float")]

NAME_PATTERN = r'NAME\((\w+?)\)'

def clean_line(line, keep_const=False, void=True, target=None, src=None):
	line = line.replace('data_out_t', "void" if void else target)
	line = line.replace('data_in_t', "void" if void else src)
	if not keep_const:
		line = line.replace('const', '')
	line = line.replace('* ', '*') #cython doesn't the additional space in declarations
	line = line.replace('*in', '*in_buf') #in is a reserved keyword in python
	return line.replace("{", "")

def get_postfix(target, src):
	return "_%s_%s" % (typenames.get(target, target), typenames.get(src, src))

def gen_cdefs(f, keep_const=True, void=False):
	"auto generate cython definitions"
	data = f.readlines()
	out = ""
	for target, src in combinations:
		name_postfix = get_postfix(target, src)
		for line in data:
			if not "{" in line: continue
			line = clean_line(line, keep_const, void, target, src)
			out += re.sub(NAME_PATTERN, r"\1" + name_postfix, line)
	return out	
			
def gen_combinations():
	"auto generate include statements for all defined type combinations"
	out = ""
	for target, src in combinations:
		out += """
#undef data_out_t
#undef data_in_t
#undef NAME
#define data_out_t %s
#define data_in_t %s
#define NAME(x) x##_%s_%s
  #include "_preprocess.c"
""" % (target, src, typenames.get(target, target), typenames.get(src, src))
	return out

def get_type_val(t):
	"""
	each type has an integer value
	the lower nibble defines the size of the type
	 unsigned_mask      = 0x10
         floatingpoint_mask = 0x20

	i.e. uint8_t is 0x11
	     double  is 0x28
	"""
	ret = "sizeof(%s)" % t
	if t == "double" or t == "float": return ret + " + 0x20"
	if "u" in t: ret += " + 0x10"
	return ret

class RawString:
	"""
	string whose repr(x) is unquoted
	"""
	def __init__(self, s):
		self.s = s
	def __repr__(self):
		return self.s

def gen_type_map():
	mp = {}
	types = {}
	for i, (target, src) in enumerate(combinations):
		types[target] = RawString(get_type_val(target))
		types[src] = RawString(get_type_val(src))
		mp[RawString("_T(types.%s, types.%s)" % (target, src))] = i
	return mp, types
	
	
def gen_types(f):
	pat = re.compile(NAME_PATTERN)
	func_types = []
	names = []
	for line in f:
		if not "{" in line: continue
		line = clean_line(line, keep_const=False, void=True)
		names.append( pat.search(line).group(1) )
		func_types.append( re.sub(NAME_PATTERN , r"(*\1)", line).replace("\n", " nogil\n" ))

	mp, types = gen_type_map()
	out = """
class types(object):
	pass
%s

t_map = %s

cdef struct _F:
	%s

cdef _F mod[%d]
""" % ("\n".join(["types.%s = %s" % v for v in types.iteritems()]), repr(mp), "\t".join(func_types), len(combinations))
 
	for i, (target, src) in enumerate(combinations):
		name_postfix = get_postfix(target, src)
		out += "mod[%d] = _F(%s)\n" % (i, ", ".join([i + name_postfix for i in names]))

	return out

msg = "This file is autogenerated from '_preprocess.c' using './autogen'.\n * DO NOT EDIT MANUALLY *"

if __name__=="__main__":
	import sys
	if sys.argv[1] == "preprocess.h":
		print """/* %s */
#include <stdint.h>

%s""" % (msg, gen_cdefs(sys.stdin).replace("\n", ";\n"))


	if sys.argv[1] == "preprocess.pxd":
		print """#%s
from stdint cimport *

cdef extern from "preprocess.h":
	%s
""" % (msg.replace("\n", "\n#"), gen_cdefs(sys.stdin, keep_const=False, void=True).replace("\n", "nogil \n\t"))


	if sys.argv[1] == "preprocess.c":
		print "/* %s */\n" % msg + gen_combinations()

	if sys.argv[1] == "types.pxh":
		print "#%s\n" % msg.replace("\n", "\n#") + gen_types(sys.stdin)
